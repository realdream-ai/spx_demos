
var (
	PlayModeAnimName []string
	curDir 	 int64
	runSpeedDamping float64
	PlayerMode      EPlayerMode
	isControlled    bool
	hasPressedJumpLastFrame  bool
	fireInterval float64
	fireTimer float64

)

type EPlayerMode = int64

const (
	SMALL EPlayerMode = iota
	BIG
	SHOOTING
)

const (
	SPEED         = float64(150)
	JUMP_VELOCITY = float64(500.0)
	PLAYER_MODE   = int64(1)
	GRAVITY       = float64(-980)

	minStompDegree = float64(25)
	maxStompDegree = float64(155)
	ShouldSyncCamera = true
)


func DoDie() {
	SetPhysicsMode NoPhysic
	isControlled = true
	y1 :=  ypos + 25
	y2 :=  ypos - 500
	x := xpos
	for {
		if( ypos > y1){
			break
		}
		setXYpos(x,ypos + 75 * deltaTime)
		waitNextFrame()
	}
	for {
		if( ypos < y2){
			break
		}
		setXYpos(x, ypos - 400 * deltaTime)
		waitNextFrame()
	}
	die()
}



func OnUpdate(delta float64) {
	if xpos > Camera.xpos {
		Camera.SetXYpos(xpos, Camera.ypos)
	}
	if isControlled {
		return
	}
	_,_, camSizeX,_ := Camera.ViewportRect()
	cameraLeftBound := Camera.xpos - float64(camSizeX/2.0)
	velX, velY := Velocity()
	if !IsOnFloor() {
		velY += (GRAVITY * delta)
	}

	isPressedJump :=  keyPressed(KeySpace)
	if isPressedJump && IsOnFloor() {
		velY = (JUMP_VELOCITY)
	}
	isJumpJustReleased := hasPressedJumpLastFrame && !isPressedJump
	if isJumpJustReleased && velY > 0 {
		velY = velY * 0.5
	}
	hasPressedJumpLastFrame = isPressedJump

	dir := 0
	isLeft := keyPressed(KeyLeft) || keyPressed(KeyA)
	isRight := keyPressed(KeyRight) || keyPressed(KeyD)
	if isRight {
		dir = 1
		setHeading Right
	}
	if isLeft {
		dir = -1
		setHeading Left
	}
	if dir != 0 {
		velX = (float64(dir)*SPEED)
	} else {
		velX = (MoveToward(velX, 0, SPEED))
	}
	if xpos < cameraLeftBound && velX <= 0 {
		velX = 0
	}
	if(dir != 0){
		curDir = int64(dir)
	}
	SetVelocity(velX,velY)
	TriggeraAnimation(velX, float64(dir), PlayerMode)
	if ypos < DEADLINE {
		gameStatus = FAILED
		DoDie()
	}
	if keyPressed(KeyF) {
		fire()
	}
	if(velY > 0){
		checkBrick()
	}
}

func checkBrick(){
	x,y := xpos+8, ypos+28
	sps := CheckCollision(x,y, 8, 4)
	//debugDrawRect(x,y, 8, 4, HSB(1,100,100))
	for _, item := range sps  {
        if(item != nil && item.name == "Brick") {
		    broadcast "hitBrick", item
        }
	}
}

func fire() {
	if fireTimer < 0{
		fireTimer = fireInterval
		Fireball.clone Transform{X: xpos + float64(curDir*6), Y: ypos + 16, Dir: curDir}
	}
}


func TriggeraAnimation(velX float64, direction float64, playerMode EPlayerMode) {
	animation_prefix := PlayModeAnimName[int64(playerMode)]
	if !IsOnFloor() {
		Animate(animation_prefix + "_jump")
	} else if Sign(velX) != Sign(direction) && velX != 0 && direction != 0 {
		Animate(animation_prefix + "_slide")
	} else {
		if velX != 0 {
			Animate(animation_prefix + "_run")
		} else {
			Animate(animation_prefix + "_idle")
		}
	}
}



onStart => {
	PlayModeAnimName = []string{
		"small",
		"big",
		"shooting",
	}
	fireInterval = 1
	curDir = 1
	runSpeedDamping = 0.5
	PlayerMode = SMALL
	isControlled = false
	for{
		if !IsPlaying() {
			return 
		}
		fireTimer -= deltaTime
		OnUpdate(deltaTime)
		waitNextFrame
	}
}

onTouchStart "Goomba", enemy => {
	if isControlled {
		return
	}
	angleOfCollision := RadToDeg(AngleToPoint(xpos, ypos,enemy.xpos,enemy.ypos))
	if angleOfCollision > minStompDegree && maxStompDegree > angleOfCollision {
		broadcast "killGoomba", enemy
	} else {
		DoDie()
	}
}