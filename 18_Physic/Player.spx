
var (
	PlayModeAnimName []string
	curDir 	 int64
	runSpeedDamping float64
	PlayerMode      EPlayerMode
	isControlled    bool
	hasPressedJumpLastFrame  bool
)

type EPlayerMode = int64

const (
	SMALL EPlayerMode = iota
	BIG
	SHOOTING
)

const (
	SPEED         = float64(100)//100
	JUMP_VELOCITY = float64(450.0)
	PLAYER_MODE   = int64(1)
	GRAVITY       = float64(-980)

	minStompDegree = float64(25)
	maxStompDegree = float64(155)
	ShouldSyncCamera = true
)


func DoDie() {
	SetPhysicsMode NoPhysic
	isControlled = true
	y1 :=  ypos + 25
	y2 :=  ypos - 500
	for {
		if( ypos > y1){
			break
		}
		setYpos(ypos + 75 * deltaTime)
		waitNextFrame()
	}
	for {
		if( ypos < y2){
			break
		}
		setYpos(ypos - 400 * deltaTime)
		waitNextFrame()
	}
	die()
}



func OnUpdate(delta float64) {
	if xpos > Camera.xpos {
		Camera.SetXYpos(xpos, Camera.ypos)
	}
	if isControlled {
		return
	}
	_,_, camSizeX,_ := Camera.ViewportRect()
	cameraLeftBound := Camera.xpos - float64(camSizeX/2.0)
	velX, velY := Velocity()
	if !IsOnFloor() {
		velY += (GRAVITY * delta)
	}

	isPressedJump :=  keyPressed(KeySpace)
	if isPressedJump && IsOnFloor() {
		velY = (JUMP_VELOCITY)
	}
	isJumpJustReleased := hasPressedJumpLastFrame && !isPressedJump
	if isJumpJustReleased && velY > 0 {
		velY = velY * 0.5
	}
	hasPressedJumpLastFrame = isPressedJump

	dir := 0
	isLeft := keyPressed(KeyLeft) || keyPressed(KeyA)
	isRight := keyPressed(KeyRight) || keyPressed(KeyD)
	if isRight {
		dir = 1
		setHeading Right
	}
	if isLeft {
		dir = -1
		setHeading Left
	}
	if dir != 0 {
		velX = (float64(dir)*SPEED)
	} else {
		velX = (MoveToward(velX, 0, SPEED))
	}
	if xpos < cameraLeftBound+40 && velX <= 0 {
		velX = 0
	}
	SetVelocity(velX,velY)
	TriggeraAnimation(velX, float64(dir), PlayerMode)
	if ypos < DEADLINE {
		gameStatus = FAILED
		DoDie()
	}
}

func getAnimDir() int64 {
	return curDir
}

func setAnimSign(isRight bool) {
	dir := int64(1)
	if !isRight {
		dir = -1
	}
	curDir = dir
}

func TriggeraAnimation(velX float64, direction float64, playerMode EPlayerMode) {
	animation_prefix := PlayModeAnimName[int64(playerMode)]
	if !IsOnFloor() {
		Animate(animation_prefix + "_jump")
	} else if Sign(velX) != Sign(direction) && velX != 0 && direction != 0 {
		Animate(animation_prefix + "_slide")
		setAnimSign(direction > 0.5)
	} else {
		if getAnimDir() != Sign(velX) && Sign(velX) != 0 {
			setAnimSign(Sign(velX) == 1)
		}
		if velX != 0 {
			Animate(animation_prefix + "_run")
		} else {
			Animate(animation_prefix + "_idle")
		}
	}
}



onStart => {
	PlayModeAnimName = []string{
		"small",
		"big",
		"shooting",
	}
	curDir = 1
	runSpeedDamping = 0.5
	PlayerMode = SMALL
	isControlled = false
	for{
		if !IsPlaying() {
			return 
		}
		OnUpdate(deltaTime)
		waitNextFrame
	}
}

onTouchStart "Goomba", enemy => {
	if isControlled {
		return
	}
	angleOfCollision := RadToDeg(AngleToPoint(xpos, ypos,enemy.xpos,enemy.ypos))
	if angleOfCollision > minStompDegree && maxStompDegree > angleOfCollision {
		enemy.(*Goomba).SetPhysicsMode NoPhysic
		enemy.Die()
	} else {
		DoDie()
	}
}